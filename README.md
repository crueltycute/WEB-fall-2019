# Структура для выполнения ЛР2 

* ex_[1-6].py — файлы с реализации заданий
* librip — пакет, который содержит различные конструкции языка для решения поставленных задач, которые необходимо реализовать
* data_light.json — облегченная версия набора вакансий (оригинал в xml http://data.gov.ru/opendata/7710538364-vacansii). Необходим для заданий 5 и 6

## Задание
Важно выполнять все задачи последовательно. С 1 по 5 задачу формируется модуль librip, с помощью которого будет выполняться задание 6 на реальных данных из жизни. Весь вывод на экран (даже в столбик) необходимо запрограммировать одной строкой.


### Задача 1 (ex_1.py)
Необходимо реализовать генераторы field и gen_random. Генератор field последовательно выдает значения ключей словарей массива.

Пример:

```python
goods = [
    {'title': 'Ковер', 'price': 2000, 'color': 'green'},
    {'title': 'Диван для отдыха', 'color': 'black'}
 ]
 
 # вывод для field(goods, 'title')
 'Ковер', 'Диван для отдыха'
 
 # вывод для field(goods, 'title', 'price')
 {'title': 'Ковер', 'price': 2000}, {'title': 'Диван для отдыха'}
 ```

В качестве первого аргумента генератор принимает list, дальше через *args генератор принимает неограниченное кол-во аргументов.
Если передан один аргумент, генератор последовательно выдает только значения полей, если поле равно None, то элемент пропускается. Если передано несколько аргументов, то последовательно выдаются словари, если поле равно None, то оно пропускается, если все поля None, то пропускается целиком весь элемент.

Генератор gen_random последовательно выдает заданное количество случайных чисел в заданном диапазоне.

Пример:
`gen_random(1, 3, 5)` должен выдать 5 чисел от 1 до 3, т.е. примерно 2, 2, 3, 2, 1

В ex_1.py нужно вывести на экран то, что они выдают, с помощью кода в одну строку
Генераторы должны располагаться в librip/gen.py

### Задача 2 (ex_2.py)

Необходимо реализовать итератор, который принимает на вход массив или генератор и итерируется по элементам, пропуская дубликаты. Конструктор итератора также принимает на вход именной bool-параметр ignore_case, в зависимости от значения которого будут считаться одинаковыми строки в разном регистре. По умолчанию этот параметр равен False. Итератор не должен модифицировать возвращаемые значения.
 
Примеры:

 ```python
 data = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2]
 1 2
 ```

```python
data = gen_random(1, 3, 10)
1 2, 3
```

```
data = [‘a’, ‘b’, ‘A’, ‘B’]
a A b B  # ignore_case=False 
a b  # ignore_case=True 
```

В ex_2.py нужно вывести на экран то, что они выдают одной строкой. Важно продемонстрировать работу как с массивами, так и с генераторами (gen_random).
Итератор должен располагаться в librip/iterators.py

### Задача 3 (ex_3.py)
Дан массив с положительными и отрицательными числами. Необходимо одной строкой вывести на экран массив, отсортированный по модулю. Сортировку осуществлять с помощью функции sorted

Пример:

```python
data = [4, -30, 100, -100, 123, 1, 0, -1, -4]
[0, 1, -1, 4, -4, -30, 100, -100, 123]
```


### Задача 4 (ex_4.py)
Необходимо реализовать декоратор print_result, который выводит на экран результат выполнения функции. Файл ex_4.py не нужно изменять.
Декоратор должен принимать на вход функцию, вызывать её, печатать в консоль имя функции, печатать результат и возвращать значение. 
Если функция вернула список (list), то значения должны выводиться в столбик.
Если функция вернула словарь (dict), то ключи и значения должны выводить в столбик через знак равно

Пример:

```python
@print_result
def test_1():
    return 1
@print_result
def test_2():
    return 'iu'
@print_result
def test_3():
    return {'a': 1, 'b': 2}
@print_result
def test_4():
    return [1, 2]
test_1()
test_2()
test_3()
test_4()
```

На консоль выведется:

```
test_1
1
test_2
iu
test_3
a = 1
b = 2
test_4
1
2
```

Декоратор должен располагаться в librip/decorators.py

### Задача 5 (ex_5.py)
Необходимо написать контекстный менеджер, который считает время работы блока и выводит его на экран

Пример:

```python
with timer():
    sleep(5.5)
    
# Вывод
5.5
```

### Задача 6 (ex_6.py)
Мы написали все инструменты для работы с данными. Применим их на реальном примере, который мог возникнуть в жизни. В репозитории находится файл data_light.json. Он содержит облегченный список вакансий в России в формате json (ссылку на полную версию размером ~ 1 Гб. в формате xml можно найти в файле README.md).
Структура данных представляет собой массив словарей с множеством полей: название работы, место, уровень зарплаты и т.д.
В ex_6.py дано 4 функции. В конце каждая функция вызывается, принимая на вход результат работы предыдущей. За счет декоратора @print_result печатается результат, а контекстный менеджер timer выводит время работы цепочки функций.
Задача реализовать все 4 функции по заданию, ничего не изменяя в файле-шаблоне. Функции f1-f3 должны быть реализованы в 1 строку, функция f4 может состоять максимум из 3 строк.

Что функции должны делать:

* Функция f1 должна вывести отсортированный список профессий без повторений (строки в разном регистре считать равными). Сортировка должна игнорировать регистр. Используйте наработки из предыдущих заданий.
* Функция f2 должна фильтровать входной массив и возвращать только те элементы, которые начинаются со слова “программист”. Иными словами нужно получить все специальности, связанные с программированием. Для фильтрации используйте функцию filter.
* Функция f3 должна модифицировать каждый элемент массива, добавив строку “с опытом Python” (все программисты должны быть знакомы с Python). Пример: Программист C# с опытом Python. Для модификации используйте функцию map.
* Функция f4 должна сгенерировать для каждой специальности зарплату от 100 000 до 200 000 рублей и присоединить её к названию специальности. Пример: Программист C# с опытом Python, зарплата 137287 руб. Используйте zip для обработки пары специальность — зарплата.

### Формат отчета
* Титульный лист
* Задание (копируется из данных методических указаний)
* Исходный код
* Скриншоты с результатами выполнения
* Обязательные условия
* Форк репозитория на github
* ex_1.py: использование *args
* ex_2.py: ипользование **kwargs, поддержка работы как со списками, так и с генераторами
* ex_3.py: использование lambda-выражения
* ex_4.py: внутри декоратора печать должна быть реализована в одну строчку. Печать словарей и массивов должна выполняться в столбик
* ex_6.py: соблюдения кол-ва строк и использование функций, указанных в задании
* Путь до файла передается как аргумент при запуске скрипта
* Код на github